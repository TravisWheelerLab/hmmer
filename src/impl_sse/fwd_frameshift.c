/* SSE implementation of Forward and Backward algorithms.
 *
 * Both profile and DP matrix are striped and interleaved, for fast
 * SIMD vector operations. Calculations are in probability space
 * (scaled odds ratios, actually) rather than log probabilities,
 * allowing fast multiply/add operations rather than slow Logsum()
 * calculations. Sparse rescaling is used to achieve full dynamic
 * range of scores.
 * 
 * The Forward and Backward implementations may be used either in a
 * full O(ML) mode that keeps an entire DP matrix, or in a O(M+L)
 * linear memory "parsing" mode that only keeps one row of memory for
 * the main MDI states and one column 0..L for the special states
 * B,E,N,C,J. Keeping a full matrix allows subsequent stochastic
 * traceback or posterior decoding of any state. In parsing mode, we
 * can do posterior decoding on the special states and determine
 * regions of the target sequence that are generated by the
 * nonhomology states (NCJ) versus not -- thus, identifying where
 * high-probability "regions" are, the first step of identifying the
 * domain structure of a target sequence.
 * 
 * Contents:
 *   1. Forward/Backward wrapper API
 *   2. Forward and Backward engine implementations
 *   4. Benchmark driver.
 *   5. Unit tests.
 *   6. Test driver.
 *   7. Example.
 * 
 * SRE, Thu Jul 31 08:43:20 2008 [Janelia]
 */
#include "p7_config.h"

#include <stdio.h>
#include <math.h>

#include <xmmintrin.h>		/* SSE  */
#include <emmintrin.h>		/* SSE2 */

#include "easel.h"
#include "esl_sse.h"

#include "hmmer.h"
#include "impl_sse.h"

static int forward_engine (int do_full, const ESL_DSQ *dsq, int L, const P7_OPROFILE *om,                    P7_OMX *fwd, float *opt_sc);
int convert_emissions(P7_OPROFILE *om, int allocM, int allocL, float **emit_sc);


/*****************************************************************
 * 1. Forward/Backward API.
 *****************************************************************/

/* Function:  p7_Forward()
 * Synopsis:  The Forward algorithm, full matrix fill version.
 * Incept:    SRE, Fri Aug 15 18:59:43 2008 [Casa de Gatos]
 *
 * Purpose:   Calculates the Forward algorithm for sequence <dsq> of
 *            length <L> residues, using optimized profile <om>, and a
 *            preallocated DP matrix <ox>. Upon successful return, <ox>
 *            contains the filled Forward matrix, and <*opt_sc>
 *            optionally contains the raw Forward score in nats.
 *            
 *            This calculation requires $O(ML)$ memory and time.
 *            The caller must provide a suitably allocated full <ox>
 *            by calling <ox = p7_omx_Create(M, L, L)> or
 *            <p7_omx_GrowTo(ox, M, L, L)>.
 *
 *            The model <om> must be configured in local alignment
 *            mode. The sparse rescaling method used to keep
 *            probability values within single-precision floating
 *            point dynamic range cannot be safely applied to models in
 *            glocal or global mode.
 *
 * Args:      dsq     - digital target sequence, 1..L
 *            L       - length of dsq in residues          
 *            om      - optimized profile
 *            ox      - RETURN: Forward DP matrix
 *            opt_sc  - RETURN: Forward score (in nats)          
 *
 * Returns:   <eslOK> on success. 
 *
 * Throws:    <eslEINVAL> if <ox> allocation is too small, or if the profile
 *            isn't in local alignment mode.
 *            <eslERANGE> if the score exceeds the limited range of
 *            a probability-space odds ratio.
 *            In either case, <*opt_sc> is undefined.
 */
int
p7_Forward_Frameshift_SIMD(const ESL_DSQ *dsq, int L, P7_OPROFILE *om, P7_OMX *ox, float **emit_sc, float *opt_sc)
{
#if eslDEBUGLEVEL > 0		
  if (om->M >  ox->allocQ4*4)    ESL_EXCEPTION(eslEINVAL, "DP matrix allocated too small (too few columns)");
  if (L     >= ox->validR)       ESL_EXCEPTION(eslEINVAL, "DP matrix allocated too small (too few MDI rows)");
  if (L     >= ox->allocXR)      ESL_EXCEPTION(eslEINVAL, "DP matrix allocated too small (too few X rows)");
  if (! p7_oprofile_IsLocal(om)) ESL_EXCEPTION(eslEINVAL, "Forward implementation makes assumptions that only work for local alignment");
#endif

  convert_emissions(om, om->M, om->L, emit_sc);
  
  ESL_STOPWATCH *watch = esl_stopwatch_Create();
  esl_stopwatch_Start(watch);


  int r = forward_engine(TRUE, dsq, L, om, ox, opt_sc);
  
  esl_stopwatch_Stop(watch);
  esl_stopwatch_Display(stdout, watch, "\tparallel time");
  esl_stopwatch_Destroy(watch);

  return r;
}

/*****************************************************************
 * 2. Forward/Backward engine implementations (called thru API)
 *****************************************************************/

int
convert_emissions(P7_OPROFILE *om, int allocM, int allocL, float **emit_sc)
{
  int i, k, q, z;
  int status;
  float *rsc;

  int          nqf = p7O_NQF(allocM); /* # of float vectors needed for query */
  union { __m128 v; float x[4]; } tmp; /* used to align and load simd minivectors               */
 
  if (om->rfv_mem   != NULL) free(om->rfv_mem);
  if (om->rfv       != NULL) free(om->rfv);
 
  ESL_ALLOC(om->rfv_mem, sizeof(__m128) * nqf * p7P_CODONS * (allocL+1) + 15); /* +15 is for manual 16-byte alignment */
  ESL_ALLOC(om->rfv, sizeof(__m128  *) * (allocL+1));

  om->rfv[0] = (__m128  *) (((unsigned long int) om->rfv_mem + 15) & (~0xf));

  for (i = 1; i <= allocL; i++) 
    om->rfv[i] = om->rfv[0] + (i * nqf * p7P_CODONS);

  for(i = 1; i <= allocL; i++) 
  {
    rsc = emit_sc[i];
    for (k = 1, q = 0; q < nqf; q++, k+=4)
      {
      for (z = 0; z < 4; z++) 
        tmp.x[z] = (k+z <= allocM) ? MSC_FS(k+z,p7P_C1) : -eslINFINITY;
      om->rfv[i][q*p7P_CODONS+p7P_C1] = esl_sse_expf(tmp.v);

      for (z = 0; z < 4; z++) 
        tmp.x[z] = (k+z <= allocM) ? MSC_FS(k+z,p7P_C2) : -eslINFINITY;
      om->rfv[i][q*p7P_CODONS + p7P_C2] = esl_sse_expf(tmp.v);

      for (z = 0; z < 4; z++)  
        tmp.x[z] = (k+z <= allocM) ? MSC_FS(k+z,p7P_C3) : -eslINFINITY;
      om->rfv[i][q*p7P_CODONS + p7P_C3] = esl_sse_expf(tmp.v);

      for (z = 0; z < 4; z++) 
        tmp.x[z] = (k+z <= allocM) ? MSC_FS(k+z,p7P_C4) : -eslINFINITY;
      om->rfv[i][q*p7P_CODONS + p7P_C4] = esl_sse_expf(tmp.v);

      for (z = 0; z < 4; z++) 
        tmp.x[z] = (k+z <= allocM) ? MSC_FS(k+z,p7P_C5) : -eslINFINITY;
      om->rfv[i][q*p7P_CODONS + p7P_C5] = esl_sse_expf(tmp.v);

      }
  
}
  
    return eslOK;

ERROR:
  return status;
}

static int
forward_engine(int do_full, const ESL_DSQ *dsq, int L, const P7_OPROFILE *om, P7_OMX *ox, float *opt_sc)
{
  int status;
  register __m128  bpv, mpv, dpv, ipv;   /* previous row values used for match state                  */
  register __m128 mdv, ddv;              /* previous column values used for delete state              */ 
  register __m128 xEv;		         /* E state: keeps max for Mk->E as we go                     */
  register __m128 xBv;		         /* B state: splatted vector of B[i-3] for B->Mk calculations */
  __m128   zerov;		         /* splatted 0.0's in a vector                                */
  float    dd;                           /* final D state value from previous D state vecotor         */
  float    xN, xE, xB, xC, xJ;	         /* special states' scores                                    */
  float    totscales[3];                 /* holds scaling factors for seperate frames                 */
  int      i;			         /* counter over sequence positions 1..L                      */
  int      q;			         /* counter over quads 0..nq-1                                */
  int      j;			         /* counter over DD iterations (4 is full serialization)      */
  int      c;                            /* counter over codon lookbacks 1..5                         */
  int      Q  = p7O_NQF(om->M);	         /* segment length: # of vectors                              */
  __m128  *dpc = ox->dpf[0];             /* current row, for use in {MDI}MO(dpp,q) access macro       */
  __m128  *dpp;                          /* previous row, for use in {MDI}MO(dpp,q) access macro      */
  __m128  *rp;			         /* will point at om->rfv[x] for residue x[i]                 */
  __m128  *tp;			         /* will point into (and step thru) om->tfv                   */
  __m128  *tpivv, *tcivv;                /* temporary pointers for shuffleing intermeidate values     */
  __m128  *ivv_mem;	                 /* memory to store intermiediate values                      */ 
  __m128  **ivv;			 /* pointers for intermiediate values                         */	
  union   { __m128 v; float f[4]; } tD;  /* used for serialized DD calculations                       */ 
  union   { __m128 v; float f[4]; } DD;  /* used for serialized DD transitions                        */
   

  union   { __m128 v; float f[4]; } temp;
  ESL_ALLOC(ivv_mem, sizeof(__m128)    * p7X_CODONS * Q + 15);   
  ESL_ALLOC(ivv,     sizeof(__m128  *) * p7X_CODONS         );
  
  ivv[0] = (__m128  *) ( ( (unsigned long int) ((char *) ivv_mem + 15) & (~0xf)));
  
  for (c = 1; c < p7X_CODONS; c++) 
    ivv[c] = ivv[0] + c * Q;

  /* Initialization. */
  ox->M  = om->M;
  ox->L  = L;
  ox->has_own_scales = TRUE;   /* all forward matrices control their own scalefactors */
  ox->xmx[p7X_SCALE] = 1.0;
  ox->totscale       = 0.0;
  totscales[0] = totscales[1] = totscales[2] = 0.0;
  zerov  = _mm_setzero_ps();
  
  /* Intermidiate value vector intialization*/
  for (c = 0; c < p7X_CODONS; c++)
    for (q = 0; q < Q; q++)
	  ivv[c][q] = zerov;
 
  /* Zeroth Row */
  xE = ox->xmx[0*p7X_NXCELLS+p7X_E] = 0.;
  xJ = ox->xmx[0*p7X_NXCELLS+p7X_J] = 0.;
  xC = ox->xmx[0*p7X_NXCELLS+p7X_C] = 0.;
  xN = ox->xmx[0*p7X_NXCELLS+p7X_N] = 1.;
  xB = ox->xmx[0*p7X_NXCELLS+p7X_B] = om->xf[p7O_N][p7O_MOVE];
 
  for (q = 0; q < Q; q++)
  {
    MMO_FS(dpc,q,p7X_C0) = zerov;
    MMO_FS(dpc,q,p7X_C1) = zerov;
    MMO_FS(dpc,q,p7X_C2) = zerov;
    MMO_FS(dpc,q,p7X_C3) = zerov;
    MMO_FS(dpc,q,p7X_C4) = zerov;
    MMO_FS(dpc,q,p7X_C5) = zerov;
    DMO_FS(dpc,q) = zerov;
    IMO_FS(dpc,q) = zerov;
  }

#if eslDEBUGLEVEL > 0
  if (ox->debugging) p7_omx_fs_DumpFBRow(ox,FALSE, 0, 9, 5, xE, xN, xJ, xB, xC);	/* logify=TRUE, <rowi>=0, width=8, precision=5*/
#endif
  
  /* Rows 1 and 2  */
  for (i = 1; i < 3; i++) 
  {
    dpc = ox->dpf[do_full * i];
    xE = ox->xmx[i*p7X_NXCELLS+p7X_E] = 0.;
    xJ = ox->xmx[i*p7X_NXCELLS+p7X_J] = 0.;
    xC = ox->xmx[i*p7X_NXCELLS+p7X_C] = 0.;
    xN = ox->xmx[i*p7X_NXCELLS+p7X_N] = om->xf[p7O_N][p7O_LOOP];
    xB = ox->xmx[i*p7X_NXCELLS+p7X_B] = xN * om->xf[p7O_N][p7O_MOVE];
    for (q = 0; q < Q; q++)
    {
      MMO_FS(dpc,q,p7X_C0) = zerov;	
      MMO_FS(dpc,q,p7X_C1) = zerov;
      MMO_FS(dpc,q,p7X_C2) = zerov;
      MMO_FS(dpc,q,p7X_C3) = zerov;
      MMO_FS(dpc,q,p7X_C4) = zerov;
      MMO_FS(dpc,q,p7X_C5) = zerov;	
      DMO_FS(dpc,q) = zerov;
      IMO_FS(dpc,q) = zerov;
    }
#if eslDEBUGLEVEL > 0
    if (ox->debugging) p7_omx_fs_DumpFBRow(ox, FALSE, i, 9, 5, xE, xN, xJ, xB, xC);	
#endif
  }

  /*  Main loop 3..L  */
  for (i = 3; i <= L; i++)
  {
     /* Set special and temporary vectors */	
    dpp   = dpc;                      
    dpc   = ox->dpf[do_full * i];     /* avoid conditional, use do_full as kronecker delta */
    
    rp    = om->rfv[i];
    tp    = om->tfv;

    xEv   = zerov;
    xBv   = _mm_set1_ps(ox->xmx[(i-3)*p7X_NXCELLS+p7X_B]);
    mpv = zerov;
    ipv = zerov; 
    dpv = zerov;

    mdv = zerov;
    dd = 0.;
 
    /* Move intermediate value pointers so that i-4 becomes i-5, i-3 becomes i-4, etc. */
    tpivv = ivv[p7P_C1];
    for(c = p7P_C2; c <= p7P_C5; c++)
    {
      tcivv = ivv[c];        	    
      ivv[c] = tpivv;
      tpivv = tcivv;
    }
    ivv[p7P_C1] = tcivv;

    for (q = 0; q < Q; q++)
    {
      /* shift vectors with i-1 values for C1 intermdediate values */
      mpv = _mm_shuffle_ps(mpv, MMO_FS(dpp,q,p7X_C0), _MM_SHUFFLE(0, 0, 3, 3));
      mpv = _mm_shuffle_ps(mpv,   MMO_FS(dpp,q,p7X_C0), _MM_SHUFFLE(2, 1, 2, 1));

      ipv = _mm_shuffle_ps(ipv, IMO_FS(dpp,q), _MM_SHUFFLE(0, 0, 3, 3));
      ipv = _mm_shuffle_ps(ipv,   IMO_FS(dpp,q), _MM_SHUFFLE(2, 1, 2, 1));

      dpv = _mm_shuffle_ps(dpv, DMO_FS(dpp,q), _MM_SHUFFLE(0, 0, 3, 3));
      dpv = _mm_shuffle_ps(dpv,   DMO_FS(dpp,q), _MM_SHUFFLE(2, 1, 2, 1));
     
      /* M->M, I->M & D->M values */	  	 
      ivv[p7P_C1][q] =            _mm_mul_ps(mpv, *tp); tp++;
      ivv[p7P_C1][q] = _mm_add_ps(_mm_mul_ps(ipv, *tp), ivv[p7P_C1][q]); tp++;
      ivv[p7P_C1][q] = _mm_add_ps(_mm_mul_ps(dpv, *tp), ivv[p7P_C1][q]); tp++;
      /* B->M value */
      bpv = _mm_mul_ps(xBv, *tp); tp++;

      /* combine intermeiate values with emittions probablities for 5 codon types */
      MMO_FS(dpc,q,p7X_C1) = _mm_mul_ps(ivv[p7P_C1][q], rp[q*p7P_CODONS+p7P_C1]);
      MMO_FS(dpc,q,p7X_C2) = _mm_mul_ps(ivv[p7P_C2][q], rp[q*p7P_CODONS+p7P_C2]);
      MMO_FS(dpc,q,p7X_C3) = _mm_mul_ps(_mm_add_ps(bpv, ivv[p7P_C3][q]), rp[q*p7P_CODONS+p7P_C3]);
      MMO_FS(dpc,q,p7X_C4) = _mm_mul_ps(ivv[p7P_C4][q], rp[q*p7P_CODONS+p7P_C4]);
      MMO_FS(dpc,q,p7X_C5) = _mm_mul_ps(ivv[p7P_C5][q], rp[q*p7P_CODONS+p7P_C5]);
     
      /* combine 5 codon types and B->M probablity to get total match state probability */
      MMO_FS(dpc,q,p7X_C0) = _mm_add_ps( MMO_FS(dpc,q,p7X_C1), MMO_FS(dpc,q,p7X_C2));
      MMO_FS(dpc,q,p7X_C0) = _mm_add_ps( MMO_FS(dpc,q,p7X_C0), MMO_FS(dpc,q,p7X_C3));
      MMO_FS(dpc,q,p7X_C0) = _mm_add_ps( MMO_FS(dpc,q,p7X_C0), MMO_FS(dpc,q,p7X_C4));
      MMO_FS(dpc,q,p7X_C0) = _mm_add_ps( MMO_FS(dpc,q,p7X_C0), MMO_FS(dpc,q,p7X_C5));

      /* add match states E state */
      xEv  = _mm_add_ps(xEv, MMO_FS(dpc,q,p7X_C0));

      /* shift i values for M->D calculation */
      mdv = _mm_shuffle_ps(mdv, MMO_FS(dpc,q,p7X_C0), _MM_SHUFFLE(0, 0, 3, 3));
      mdv = _mm_shuffle_ps(mdv, MMO_FS(dpc,q,p7X_C0), _MM_SHUFFLE(2, 1, 2, 1));

      /* partial delete state pobability, M->D only */
      DMO_FS(dpc,q)   = _mm_mul_ps(mdv, *tp); tp++;

      /* Now the DD paths. We would rather not serialize them but 
       * in an accurate Forward calculation, we have few options.
       */
      tD.v = DMO_FS(dpc,q);
      DD.v = *tp; tp++;

      tD.f[0] += dd * DD.f[0];	
      for (j = 1; j < 4; j++) 
        tD.f[j] += tD.f[j-1] * DD.f[j];
 
      DMO_FS(dpc,q) =  tD.v;	 
	if(i == 3) {
	 temp.v = DMO_FS(dpc,q);

	}

      /* Add D's to xEv */
      xEv = _mm_add_ps(DMO_FS(dpc,q), xEv);
 
      /* Calculate and store I(i,q); assumes odds ratio for emission is 1.0 */
      IMO_FS(dpc,q) = _mm_mul_ps(ox->dpf[i-3][q * p7X_NSCELLS_FS + p7X_M + p7X_C0], *tp);  tp++;
     IMO_FS(dpc,q) = _mm_add_ps(IMO_FS(dpc,q), _mm_mul_ps(ox->dpf[i-3][q * p7X_NSCELLS_FS + p7X_I], *tp)); tp++; 
 
      mpv = MMO_FS(dpp,q,p7X_C0);
      dpv = DMO_FS(dpp,q);
      ipv = IMO_FS(dpp,q);
      
      mdv = MMO_FS(dpc,q,p7X_C0);
	  
      /* shift i values for D->D calculation */
      ddv = _mm_shuffle_ps(DMO_FS(dpc,q), DMO_FS(dpc,q), _MM_SHUFFLE(3, 3, 3, 3));  
      dd = _mm_cvtss_f32(ddv);
    } 
      
    /* Finally the "special" states, which start from Mk->E (->C, ->J->B) */
      
    /* The following incantation is a horizontal sum of xEv's elements  */
    xEv = _mm_add_ps(xEv, _mm_shuffle_ps(xEv, xEv, _MM_SHUFFLE(0, 3, 2, 1)));
    xEv = _mm_add_ps(xEv, _mm_shuffle_ps(xEv, xEv, _MM_SHUFFLE(1, 0, 3, 2)));
    _mm_store_ss(&xE, xEv);

    xN =  ox->xmx[(i-3)*p7X_NXCELLS+p7X_N] * om->xf[p7O_N][p7O_LOOP];
    xC = (ox->xmx[(i-3)*p7X_NXCELLS+p7X_C] * om->xf[p7O_C][p7O_LOOP]) +  (xE * om->xf[p7O_E][p7O_MOVE]);
    xJ = (ox->xmx[(i-3)*p7X_NXCELLS+p7X_J] * om->xf[p7O_J][p7O_LOOP]) +  (xE * om->xf[p7O_E][p7O_LOOP]);
    xB = (xJ * om->xf[p7O_J][p7O_MOVE]) +  (xN * om->xf[p7O_N][p7O_MOVE]);
    /* and now xB will carry over into next i, and xC carries over after i=L */
    /* Sparse rescaling. xE above threshold? trigger a rescaling event.            */

#if 0
    if (xE > 1.0e4)	/* that's a little less than e^10, ~10% of our dynamic range */
    {
      xN  = xN / xE;
      xC  = xC / xE;
      xJ  = xJ / xE;
      xB  = xB / xE;
      xEv = _mm_set1_ps(1.0 / xE);
      for (q = 0; q < Q; q++)
      {
        MMO_FS(dpc,q, p7X_C0) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C0), xEv);
        MMO_FS(dpc,q, p7X_C1) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C1), xEv);
        MMO_FS(dpc,q, p7X_C2) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C2), xEv);
        MMO_FS(dpc,q, p7X_C3) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C3), xEv);
        MMO_FS(dpc,q, p7X_C4) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C4), xEv);
        MMO_FS(dpc,q, p7X_C5) = _mm_mul_ps(MMO_FS(dpc,q,p7X_C5), xEv);
	DMO_FS(dpc,q) = _mm_mul_ps(DMO_FS(dpc,q), xEv);
	IMO_FS(dpc,q) = _mm_mul_ps(IMO_FS(dpc,q), xEv);
      }
      ox->xmx[i*p7X_NXCELLS+p7X_SCALE] = xE;

      ox->totscale += log(xE);
      
      xE = 1.0;		
    }
    else ox->xmx[i*p7X_NXCELLS+p7X_SCALE] = 1.0;
#endif

    /* Storage of the specials.  We could've stored these already
     * but using xE, etc. variables makes it easy to convert this
     * code to O(M) memory versions just by deleting storage steps.
     */
    ox->xmx[i*p7X_NXCELLS+p7X_E] = xE;
    ox->xmx[i*p7X_NXCELLS+p7X_N] = xN;
    ox->xmx[i*p7X_NXCELLS+p7X_J] = xJ;
    ox->xmx[i*p7X_NXCELLS+p7X_B] = xB;
    ox->xmx[i*p7X_NXCELLS+p7X_C] = xC;

#if eslDEBUGLEVEL > 0
   if (ox->debugging) p7_omx_fs_DumpFBRow(ox, FALSE, i, 9, 5, xE, xN, xJ, xB, xC);	/* logify=TRUE, <rowi>=i, width=8, precision=5*/
#endif
  } /* end loop over sequence residues 1..L */

  /* finally C->T, and flip total score back to log space (nats) */
  /* On overflow, xC is inf or nan (nan arises because inf*0 = nan). */
  /* On an underflow (which shouldn't happen), we counterintuitively return infinity:
   * the effect of this is to force the caller to rescore us with full range.
   */
  xC = ox->xmx[(L)*p7X_NXCELLS+p7X_C] + ox->xmx[(L-1)*p7X_NXCELLS+p7X_C] + ox->xmx[(L-2)*p7X_NXCELLS+p7X_C];
  
  if       (isnan(xC))        ESL_EXCEPTION(eslERANGE, "forward score is NaN");
  else if  (L>0 && xC == 0.0) ESL_EXCEPTION(eslERANGE, "forward score underflow (is 0.0)");     /* if L==0, xC *should* be 0.0; J5/118 */
  else if  (isinf(xC) == 1)   ESL_EXCEPTION(eslERANGE, "forward score overflow (is infinity)");

  if (opt_sc != NULL) *opt_sc = log(xC * om->xf[p7O_C][p7O_MOVE]);
  
  if(ivv_mem != NULL) free(ivv_mem);
  if(ivv     != NULL) free(ivv);

  return eslOK;

ERROR:
  if(ivv_mem != NULL) free(ivv_mem);
  if(ivv     != NULL) free(ivv);
  return status;
}




